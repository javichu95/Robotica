#pragma config(Sensor, S1,     sonar,          sensorSONAR)
#pragma config(Sensor, S2,     cam,            sensorI2CCustomFastSkipStates)
#pragma config(Sensor, S3,     lightSensor,    sensorLightActive)
#pragma config(Sensor, S4,     gyro,           sensorAnalogInactive)
#pragma config(Motor,  motorB,          r_motor,       tmotorNXT, PIDControl)
#pragma config(Motor,  motorC,          l_motor,       tmotorNXT, PIDControl)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////
//  Conjunto de funciones que se encargan de inicializar todas las tareas del          //
//  trabajo.                                                                           //
/////////////////////////////////////////////////////////////////////////////////////////


short valorColor = 40;		// Valor umbral para elegir el mapa.

// Librerías para el mapa.
#include "mapLib.c"

#define BLUE 1
#define COLOR_PUERTA BLUE

// Coordenadas para la planificación hasta la sala de la pelota.
int inicialBlancaX = 3;
int inicialBlancaY = 15;
int inicialNegraX = 11;
int inicialNegraY = 15;
int finSBlancaX = 3;
int finSBlancaY = 7;
int finSNegraX = 11;
int finSNegraY = 7;
int pelotaX = 7;
int pelotaY = 9;
// Coordenadas para la tira blanca.
int tiraEnNegro = 8;
int tiraEnBlanco = 6;

int puertaX = 0;
int puertaY = 0;

/*
* Método que da vuelta cuando acaba el circuito.
*/
void terminar(){

	abrirPinza();			// Se abre la pinza.
	setSpeed(0,numPi/2);			// Se fija la velocidad.
	wait1Msec(5000);
	setSpeed(0,-numPi/2);			// Se fija la velocidad.
	wait1Msec(5000);
	setSpeed(0,0);
}

/*
* Método que realiza la S en una cierta dirección dada.
*/
void realizarS(bool dir){

	float v = 150.0, w = 0.0;       // Velocidades lineal y angular.
  float radio = 400; 				     	// Radio de la trayectoria.
  float x, y, theta;							//variables para odometria.

	if(dir){			// Se comprueba la dirección de la S.
		// Primer tramo: MEDIA CIRCUNFERENCIA.
		w = v/radio;			// Se calcula la velocidad angular.
		readOdometry(x, y, theta); 		//Se lee la odometria.
		drawRobot(x, y, theta, inicialBlancaX, inicialBlancaY);				//Se dibula el robot.
		setSpeed(v,w);   // Se fijan las velocidades.
		wait1Msec(abs(numPi/w)*1000.0);

		// Segundo tramo: MEDIA CIRCUNFERENCIA.
		readOdometry(x, y, theta); 		//Se lee la odometria.
		drawRobot(x, y, theta, inicialBlancaX, inicialBlancaY);				//Se dibula el robot.
		setSpeed(v,-w);   // Se fijan las velocidades.
		wait1Msec(abs(numPi/w)*1000.0);

		// Tercer tramo: GIRO 90º.
		readOdometry(x, y, theta); 		//Se lee la odometria.
		drawRobot(x, y, theta, inicialBlancaX, inicialBlancaY);				//Se dibula el robot.
		w = numPi/2.0;			// Se asigna la velocidad angular.
		setSpeed(0,w);	// Velocidad lineal a 0 para que el robot gire sobre si mismo.
		wait1Msec(abs(numPi/2.0/w)*1000.0);
		setSpeed(0,0);		// Se para la velocidad.
		readOdometry(x, y, theta); 		//Se lee la odometria.
		drawRobot(x, y, theta, inicialBlancaX, inicialBlancaY);				//Se dibula el robot.
	}

	else{			// Se comprueba la dirección de la S.
		// Primer tramo: MEDIA CIRCUNFERENCIA.
		w = v/radio;			// Se calcula la velocidad angular.
		readOdometry(x, y, theta); 		//Se lee la odometria.
		drawRobot(x, y, theta, inicialNegraX, inicialNegraY);				//Se dibula el robot.
		setSpeed(v,-w);   // Se fijan las velocidades.
		wait1Msec(abs(numPi/w)*1000.0);

		// Segundo tramo: MEDIA CIRCUNFERENCIA.
		setSpeed(v,w);   // Se fijan las velocidades.
		readOdometry(x, y, theta); 		//Se lee la odometria.
		drawMap();										//Se dibuja el mapa.
		drawRobot(x, y, theta, inicialNegraX, inicialNegraY);				//Se dibula el robot.
		wait1Msec(abs(numPi/w)*1000.0);

		// Tercer tramo: GIRO 90º.
		w = numPi/2.0;			// Se asigna la velocidad angular.
		readOdometry(x, y, theta); 		//Se lee la odometria.
		drawRobot(x, y, theta, inicialNegraX, inicialNegraY);				//Se dibula el robot.
		setSpeed(0,-w);	// Velocidad lineal a 0 para que el robot gire sobre si mismo.
		wait1Msec(abs(numPi/2.0/w)*1000.0);
		setSpeed(0,0);			// Se para la velocidad.
		readOdometry(x, y, theta); 		//Se lee la odometria.
		drawRobot(x, y, theta, inicialNegraX, inicialNegraY);				//Se dibula el robot.<
	}

}

/*
 * Detecta la puerta de salida del laberinto.
 */
bool reconocerPuerta() {
	int _nblobs = 0;								// Número de blops detectados.
	int_array bc, bl, bt, br, bb;		// Variables para la detección de la cámara.
	//init_camera(cam);								// Se inicializa la cámara.
  	get_blobs(cam, _nblobs, bc, bl, bt, br, bb);	// Se obtienen los blops.
	for(int j = 0; j < 100; j++) {
	  for (int i = 0; i < _nblobs; i++) {		// Se recorren los blops.
	  	float area = (br[i] - bl[i])*(bb[i]-bt[i]);
			if (bc[i] == COLOR_PUERTA && area > 20){ //Si el color coincide...
				return true;
			}
		}
	}
	return false;

}

/*
 * Método 1 de salida: sale del circuito detectando las paredes y haciendo giros de 90 grados.
 */
void salirDetect(float angulo) {
	float v = 250.0, w = numPi/2;
	float x, y, theta;
	readOdometry(x,y,theta);
	float girar = theta;
	if(angulo==numPi) {
		girar = numPi - abs(theta);
		w = -w;
	}
	if(theta < 0) {
		girarHasta(girar,w);		//NEGATIVO en 180 y POSITIVO en 0
	} else {
		girarHasta(girar,-w);		//POSITIVO en 180 y NEGATIVO en 0
	}
	setSpeed(v,0);				//Se avanza hacia la pared.
	while(SensorValue[sonar] > distancia) {}
	setSpeed(0,0);
	girarHasta(numPi/2,w);			//Se avanza hacia la salida
	readOdometry(x, y, theta);
	while(redondearCoord(y)+inicialBlancaY <= 17) {						//Mientras este en el mapa.
		float recorridoY = y;
		setSpeed(v,0);						//Avanza dos baldosas.
		while(y < recorridoY+sizeCell*2) {
			readOdometry(x,y,theta);
		}
		if(y < 17) {				//Si sigue en el mapa gira y avanza de nuevo hacia la pared.
			setSpeed(0,0);
			girarHasta(numPi/2,-w);
			setSpeed(v,0);
			while(SensorValue[sonar] > distancia) {}
			setSpeed(0,0);
			girarHasta(numPi/2,w);			//Se avanza hacia la salida
		}
	}
}

/*
 * Método 2 de salida: sale del circuito por la puerta correspondiente, detectando las paredes,
 * y haciendo giros del ángulo necesario para encaminarse hacia la salida.
 */
void salir(float angulo) {

	float v = 250.0, w = numPi/2;
	float x, y, theta;
	readOdometry(x,y,theta);
	float girar = theta;
	if(angulo==numPi) {				//Se comprueba la direccion de salida.
		girar = numPi - abs(theta);
		w = -w;
	}
	if(theta < 0) {					//Se pone en la dirección correcta.
		girarHasta(girar,w);		//NEGATIVO en 180 y POSITIVO en 0.
	} else {
		girarHasta(girar,-w);		//POSITIVO en 180 y NEGATIVO en 0.
	}
	setSpeed(v,0);						//Se avanza hacia la pared.
	while(SensorValue[sonar] > distancia) {}			//Una vez detectada la pared se para.
	setSpeed(0,0);
	readOdometry(x,y,theta);
	girar = numPi/2 - theta;				//Se gira hacia la salida.
	girarHasta(girar,w);
	setSpeed(v,0);									//Avanza hasta salir del mapa.
	while(redondearCoord(y)+inicialBlancaY <= 17) {
		readOdometry(x,y,theta);
	}
	setSpeed(0,0);

	if(angulo == numPi){			//Dibuja la posicion de salida.
		drawRobot(sizeCell*1,15*sizeCell,numPi/2,celdaOdoX,celdaOdoY);			// Se dibuja la posición de salida.
	} else{
		drawRobot(7*sizeCell,15*sizeCell,numPi/2,celdaOdoX,celdaOdoY);			// Se dibuja la posición de salida.
	}
}

/*
* Método que ejecuta el circuito si la salida es la blanca.
*/
void ejecutarBlanca(){

	float x, y, theta;		//Variables para odometria.

	// Variables para la puerta.
	puertaX = 9;
	puertaY = 13;

	xTiraBlanca = tiraEnBlanco + 1;			// Se asigna la posición de la tira blanca.

	string mapa = "mapaA.txt";		// Se asigna el mapa.
	loadMap(mapa);		// Se carga el mapa A.

	drawMap();		// Se dibuja el mapa.

	realizarS(true);		// Se hace la S a la derecha.

	// Se planifica el camino desde la celda final de la S.
	planPath(finSBlancaX, finSBlancaY, pelotaX, pelotaY,
				inicialBlancaX, inicialBlancaY);
	encontrarCamino(finSBlancaX,finSBlancaY);		// Se encuentra el camino.
	recorrerCamino(true);		// Se recorre el camino.

	// Se lee odometría.
	readOdometry(x, y,theta);
	resetOdometry(800,-1600,theta);		// Se resetea odometría.

	drawRobot(800, -1600, theta, celdaOdoX, celdaOdoY);		//Se dibuja el robot.

	planPath(pelotaX, pelotaY, puertaX, puertaY,		// Se planifica hasta la cartulina.
			inicialBlancaX, inicialBlancaY);
	encontrarCamino(pelotaX, pelotaY);		// Se encuentra el camino.
	recorrerCamino(false);		// Se recorre el camino.
	float angulo = 0.0;			// Ángulo de salida.
	if(reconocerPuerta()) {			// Se reconoce la puerta.
		angulo = numPi;
	}
	buscarAtrapar();		// Se busca la pelota y se atrapa.

	readOdometry(x, y, theta);			//Se lee la odometria.
	drawRobot(x, y, theta, inicialBlancaX, inicialBlancaY);		//Se dibuja el robot.

	setSpeed(0,0);		// Se para la velocidad.

	salir(angulo);		// Se recorre el camino hasta la salida.

}

/*
* Método que ejecuta el circuito si la salida es negra.
*/
void ejecutarNegra(){

	float x, y, theta;		//Variables para odometria.

	// Variables para la puerta.
	puertaX = 5;
	puertaY = 13;

	xTiraBlanca = tiraEnNegro - 1;		// Se asigna la posición de la tira blanca.

	string mapa = "mapaB.txt";		// Se asigna el mapa.
	loadMap(mapa);		// Se carga el mapa B.

	drawMap();		// Se dibuja el mapa.

	realizarS(false);		// Se hace la S a la derecha.

	// Se planifica el camino desde la celda final de la S.
	planPath(finSNegraX, finSNegraY, pelotaX, pelotaY,
				inicialNegraX, inicialNegraY);

	encontrarCamino(finSNegraX,finSNegraY);		// Se encuentra el camino.

	recorrerCamino(true);		// Se recorre el camino.

	readOdometry(x, y,theta);		// Se lee la odometría.
	resetOdometry(-800,-1600,theta);		// Se resetea la odometría.

	drawRobot(-800, -1600, theta, celdaOdoX, celdaOdoY);		//Se dibuja el robot.

	planPath(pelotaX, pelotaY, puertaX, puertaY,		// Se planifica hasta la cartulina.
		inicialNegraX, inicialNegraY);
	encontrarCamino(pelotaX, pelotaY);		// Se encuentra el camino.
	recorrerCamino(false);			// Se recorre el camino.

	float angulo = 0.0;			// Ángulo de salida.

	if(reconocerPuerta()) {			// Se reconoce la puerta.
		angulo = numPi;
	}

	buscarAtrapar();		// Se busca la pelota y se atrapa.

	readOdometry(x, y, theta);			//Se lee la odometria.
	drawRobot(x, y, theta, inicialBlancaX, inicialBlancaY);		//Se dibuja el robot.

	setSpeed(0,0);			// Se para la velocidad.

	salir(angulo);		// Se recorre el camino hasta la salida.

}


/*
* Método principal que lanza la ejecución de todo el programa.
*/
task main(){
	initConnections();		// Se inicializa la matriz de conexiones.

	startTask(updateOdometry);		// Se inicializa la tarea de odometría.

	// Se comprueba el color de la línea para cargar un mapa u otro.
	if(SensorValue(lightSensor) > valorColor){		// Salida blanca.
		// Se fija la posición de la odometría.
		set_position(robot_odometry, INI_X, INI_Y, numPi);
		ejecutarBlanca();
	}
	else{			// Salida negra.
		// Se fija la posición de la odometría.
		set_position(robot_odometry, INI_X, INI_Y, 0.0);
		ejecutarNegra();
	}

	stopTask(updateOdometry);			// Se para la tarea de odometría.

	terminar();			// Método que da vueltas al acabar.

	wait1Msec(500000);		// Se espera para ver el mapa.
}
