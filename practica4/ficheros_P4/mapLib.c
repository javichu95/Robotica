//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "controlVelocidad.c"

// DEFINIR EL MAXIMO NUMERO DE CELDAS QUE PODEMOS UTILIZAR
#define MAX_X 10
#define MAX_Y 10

TFileIOResult nIoCuadricula;
TFileHandle hFileHandleCuad = 0;
short nFileSizeCuad = 20000;			// Tama??el fichero.
string cuadricula = "grid.txt";     // Nombre del fichero.

// Variables globales de las dimensiones del mapa
int sizeX;
int sizeY;
int sizeCell;
int pixPerX;
int pixPerY;
// Coordenadas de la celda final.
int celdaXFin;
int celdaYFin;

// Matriz de conexiones.
bool connectionsMatrix[2*MAX_X+1][2*MAX_Y+1];
// Matrices con los caminos.
int pathX[MAX_X*MAX_Y];
int pathY[MAX_X*MAX_Y];

// Cuadrícula para encontrar el camino.
int grid[MAX_X*2][MAX_Y*2];

/*
 * Inicializa todas las conexiones a falso.
 */
void initConnections(){

  for(int i=0; i<2*MAX_X+1; ++i){
    for (int j=0; j<2*MAX_Y+1; ++j){
      connectionsMatrix[i][j]=false;
    }
  }

}

/* pasar de una celda(cellX,cellY) y un indice de vecindad numNeigh,
al correspondiente punto en la matriz de conexiones (connX,connY) */
void cell2connCoord(int cellX, int cellY, int numNeigh, int & connX, int & connY){
  connX=2*cellX+1;
  connY=2*cellY+1;
  switch(numNeigh){
    case 0: connY++; break;
    case 1: connY++; connX++; break;
    case 2: connX++;break;
    case 3: connY--; connX++; break;
    case 4: connY--; break;
    case 5: connY--; connX--; break;
    case 6: connX--; break;
    case 7: connY++; connX--; break;
  }
}

/*
 * Marca una cierta celda como conectada a otra.
 */
void setConnection(int cellX, int cellY, int numNeigh){
  int connX, connY; // coordinates in the connection matrix
  // from coordinates in the grid of cells to coordinates in the connection matrix
  cell2connCoord(cellX, cellY, numNeigh, connX, connY);
  connectionsMatrix[connX][connY]=true;
}

/*
 * Borra la conexión entre dos celdas.
 */
void deleteConnection(int cellX, int cellY, int numNeigh){
  int connX, connY; // coordinates in the connection matrix
  // from coordinates in the grid of cells to coordinates in the connection matrix
  cell2connCoord(cellX, cellY, numNeigh, connX, connY);
  connectionsMatrix[connX][connY]=false;
}

/*
 * Devuelve true si y sólo si dos celdas dadas están conectadas.
 */
bool isConnected(int cellX, int cellY, int numNeigh){
   int connX, connY; // coordinates in the connection matrix
  // from coordinates in the grid of cells to coordinates in the connection matrix
  cell2connCoord(cellX, cellY, numNeigh, connX, connY);
  return(connectionsMatrix[connX][connY]);

}


bool readLineHeader(TFileHandle hFileHandle,TFileIOResult nIoResult, int & dimX, int & dimY, int &dimCell){
    //unsigned ans;
    //short ans;
    int ind = 1;
    //float aux = 0.1;
    bool eol = false;
    bool endfile = false;
    char onechar;
    char linechar[40];
    int num = 0;
    int indNum=0;
    int numbersRead[3];

    // read header
		while(!eol){
		  ReadByte(hFileHandle, nIoResult, onechar);
		  if ( nIoResult == 0 ){ // all ok
          if (onechar==13) // end of line
          {
	          linechar[ind-1]=0;
	          eol=true;
          }
          else{
            if (onechar=='\n'){ // line jump
              //skip
            }
            else{
              linechar[ind-1]=onechar;
              if (onechar==' '){
                numbersRead[indNum]=num;
                num=0;
                indNum++;
              }else{
                num = 10*num + (onechar - '0' );
              }
              ind++;
            }
          }
       }
       else{
            if (nIoResult==ioRsltEndOfFile){
              eol=true;
              endfile=true;

            }else{
              nxtDisplayTextLine(1, "PROBLEM READING map");
            }
        }
     }
     // from char to string
     //StringFromChars(linestring,linechar);
     if (numbersRead[indNum]!=num && num!=0){
        numbersRead[indNum]=num;
     }

     dimX = numbersRead[0];
     dimY = numbersRead[1];
     dimCell = numbersRead[2];

     /*nxtDisplayTextLine(3, "%d %d ", dimX, dimY);
     nxtDisplayTextLine(4, "%d ", dimCell);
     wait10Msec(300);*/

     return endfile;
}

bool readNextLine(TFileHandle hFileHandle,TFileIOResult & nIoResult, int & mapRow){
    //short ans;

    int ind = 0; // pointer to keep all text read in vector linechar
    char linechar[(MAX_X*2+1)*3]; // how long do we expect the lines...
    string linestring;
    char onechar;

    bool eol = false;
    bool endfile = false;
    int mapCol=0;

    // read header
		while(!eol){
		  ReadByte(hFileHandle, nIoResult, onechar);
		  if ( nIoResult == 0 ){ // all ok
          if (onechar==13) // end of line
          {
	          linechar[ind]=0;
	          eol=true;
          }
          else{
            if (onechar=='\n'){ // line jump
              //skip
            }
            else{
              linechar[ind]=onechar;
              if (onechar==' '){
                //numbersRead[indNum]=num;
                //num=0;
                //indNum++;
              }else{
                if (onechar=='1'){
                  nxtDisplayTextLine(3, " %d %d", mapCol,mapRow);
                  connectionsMatrix[mapCol][mapRow]=true;
                }
                // else { false} // by default is false
                mapCol++;

              }
              ind++;
            }
          }
       }
       else{
            if (nIoResult==ioRsltEndOfFile){
              eol=true;
              endfile=true;

            }else{
              nxtDisplayTextLine(1, "PROBLEM READING map");
            }
        }
     }

     // jump to next row
     mapRow--;
     if (mapRow<0){
        // STOP READING, map is full
        endfile=true;
     }

     // from char to string
     StringFromChars(linestring,linechar);
     /*if (numbersRead[indNum]!=num && num!=0){
        numbersRead[indNum]=num;
     }*/

     nxtDisplayTextLine(3, "%s ", linestring);

     /*for(int j=2; j<=indNum; ++j){
        setConnection(numbersRead[0], numbersRead[1], numbersRead[j]);
        nxtDisplayTextLine(4, "%d connection open", numbersRead[j]);
        //wait10Msec(200);
     }*/
     return endfile;
	}

////////////////////////////////////////////////////////////////
// load map from a txt to the occupancy and connection matrix
// FILL GLOBAL VARIABLES dimX dimY cellSize
bool loadMap(string mapFileName){
     bool loadingOk=false;
     int dimConectionX,dimConectionY;
     int mapRow; // last row from connection matrix

     string line="";
     bool eof = false;
     TFileIOResult nIoResult;
     TFileHandle hFileHandle;
     short nFileSize = 0; // it is filled when we open file

     CloseAllHandles(nIoResult);
     hFileHandle = 0;
	   //nxtDrawLine(_x+2, _y, _x-2, _y);

	   OpenRead(hFileHandle, nIoResult, mapFileName, nFileSize);
	   if( nIoResult ==0 ){
	       nxtDisplayTextLine(1, "OPEN OK: %d", nFileSize);

	       //StringFromChars(sToString, FromChars)
         //Converts an array of bytes to a string value.  You MUST end your char array with a char value of zero!

	        // read first line
          eof = readLineHeader(hFileHandle,nIoResult, sizeX, sizeY, sizeCell);
          //nxtDisplayTextLine(2, "%s", line);
          mapRow=2*sizeY;
          // read rest of data
          while(!eof){
            eof = readNextLine(hFileHandle,nIoResult, mapRow);
            //eof = readNextCellConnections(hFileHandle,nIoResult);
            //nxtDisplayTextLine(2, "%s", line);
	        }
	        loadingOk=true;
	        Close(hFileHandle, nIoResult);
     }
     else{
           loadingOk=false;
           nxtDisplayTextLine(1, "PROBLEM OPENING file");
     }

	   return loadingOk;
}

/*
 * Método que dibuja el mapa por pantalla.
 */
void drawMap(){
  int i,j,cx,cy;

  eraseDisplay(); // L_B: (0,0); T_T: (99,63)
  //nxtDrawRect(_l, _t, _r, _b);
  pixPerX=100/sizeX;
  pixPerY=64/sizeY;

  nxtDrawRect(0,sizeY*pixPerY,sizeX*pixPerX,0);

  //nxtDrawLine(xPos, yPos, xPosTo, yPosTo);
  //i=cellX*sizeY+cellY;

  // check "vertical" walls
  for (i=2; i<2*sizeX; i=i+2){
    for (j=1; j< 2*sizeY; j=j+2){
      if (connectionsMatrix[i][j]==false){
          // paint "right" wall from cell (i/2-1, j2-1)
          cx=(i-1)/2;
          cy=(j-1)/2;
          nxtDrawLine((cx+1)*pixPerX, cy*pixPerY, (cx+1)*pixPerX, (cy+1)*pixPerY);
      }
    }
  }


  // check "horizontal" walls
  for (j=2; j<2*sizeY; j=j+2){
    for (i=1; i< 2*sizeX; i=i+2){
      if (connectionsMatrix[i][j]==false){
          // paint "top" wall from cell (i-1)/2, (j-1)/2)
          cx=(i-1)/2;
          cy=(j-1)/2;
          nxtDrawLine((cx)*pixPerX, (cy+1)*pixPerY, (cx+1)*pixPerX, (cy+1)*pixPerY);
      }
    }
  }

}

/*
 * Método que convierte las coordenadas del robot en odometría en coordenadas
 * de la celda.
 */
void pos2cell(float x_mm, float y_mm, int & x_cell, int & y_cell){

  x_cell =  (int) x_mm/sizeCell;

  y_cell = (int) y_mm/sizeCell;

}

/*
 * Método que dibuja el robot en la pantalla.
 */
void drawRobot(float x_mm, float y_mm, float ang_rad){
  int cellx,celly;
  int pixX,pixY;
  float ang_grad;
  int th;

  pos2cell(x_mm, y_mm, cellx,celly);

  pixX=cellx*pixPerX+pixPerX/2;
  pixY=celly*pixPerY+pixPerY/2;
  nxtFillEllipse(pixX-1, pixY+1, pixX+1, pixY-1); //nxtFillEllipse(Left, Top, Right, Bottom);

  //normalizeAngle(ang_rad);
  ang_grad=radiansToDegrees(ang_rad);
  if (ang_grad<0){ ang_grad=ang_grad+360;}
  th=(ang_grad+22.5)/45;
  while(th>7){th=th-8;}

	// Pinta la orientación.
	if(th==0)		    { nxtDrawLine(pixX,pixY,pixX+2,pixY);		}
	else if(th==1)	{ nxtDrawLine(pixX,pixY,pixX+2,pixY+2);	}
	else if(th==2)	{ nxtDrawLine(pixX,pixY,pixX,pixY+2);	  }
	else if(th==3)	{ nxtDrawLine(pixX,pixY,pixX-2,pixY+2);	}
	else if(th==4)	{ nxtDrawLine(pixX,pixY,pixX-2,pixY);		}
	else if(th==5)	{ nxtDrawLine(pixX,pixY,pixX-2,pixY-2);	}
	else if(th==6)	{ nxtDrawLine(pixX,pixY,pixX,pixY-2);		}
	else if(th==7)	{ nxtDrawLine(pixX,pixY,pixX+2,pixY-2);	}

}

/*
 * Método que va asignando costes recursivamente.
 */
void planPath(int coordenadaX, int coordenadaY, int coste) {

  // Comprueba si es una celda válida y si el coste que ya hay es mayor.
  if(grid[coordenadaX+1][coordenadaY] != -1 && coordenadaX+2 <= 2*sizeX) {
		if(grid[coordenadaX+2][coordenadaY]	< -1 || grid[coordenadaX+2][coordenadaY] > coste) {
      // Asigna el coste y realiza la llamada recursiva.
			grid[coordenadaX+2][coordenadaY] = coste;
			planPath(coordenadaX+2,coordenadaY, coste+1);
		}
	}

  // Comprueba si es una celda válida y si el coste que ya hay es mayor.
	if(grid[coordenadaX-1][coordenadaY] != -1 && coordenadaX-2 >= 0) {
		if(grid[coordenadaX-2][coordenadaY]	< -1 || grid[coordenadaX-2][coordenadaY] > coste) {
      // Asigna el coste y realiza la llamada recursiva.
			grid[coordenadaX-2][coordenadaY] = coste;
			planPath(coordenadaX-2,coordenadaY, coste+1);
		}
	}

  // Comprueba si es una celda válida y si el coste que ya hay es mayor.
	if(grid[coordenadaX][coordenadaY+1] != -1 && coordenadaY+2 <= 2*sizeY) {
		if(grid[coordenadaX][coordenadaY+2]	< -1 || grid[coordenadaX][coordenadaY+2] > coste) {
      // Asigna el coste y realiza la llamada recursiva.
			grid[coordenadaX][coordenadaY+2] = coste;
			planPath(coordenadaX,coordenadaY+2, coste+1);
		}
	}

  // Comprueba si es una celda válida y si el coste que ya hay es mayor.
	if(grid[coordenadaX][coordenadaY-1] != -1 && coordenadaY-2 >= 0) {
		if(grid[coordenadaX][coordenadaY-2]	< -1 || grid[coordenadaX][coordenadaY-2] > coste) {
      // Asigna el coste y realiza la llamada recursiva.
			grid[coordenadaX][coordenadaY-2] = coste;
			planPath(coordenadaX,coordenadaY-2, coste+1);
		}
	}

}

/*
 * Método que asigna el valor -1 a obstáculos.
 */
void asignarValores() {

	// Se recorre la matriz para poner los obstáculos.
  for(int i = 0; i <= 2*sizeX; i++){
		for(int j = 0; j <= 2*sizeY; j++){
			if(!connectionsMatrix[i][j]) {
				grid[i][j] = -1;
			}
		}
	}

}

/*
* Método que inicializa la cuadrícula con valor -2.
*/
void iniciarGrid(){

	// Recorre la cuadrícula inicializandola.
	for(int i = 0; i <= 2*sizeX; i++){
		for(int j = 0; j <= 2*sizeY; j++){
			grid[i][j] = -2;
		}
	}

}

/*
 * Método que inicializa el algoritmo NF1 para ir dando valores.
 */
void planPath(int x_ini, int y_ini, int x_end, int y_end){

	iniciarGrid();
	asignarValores();
	// Se guarda la celda final.
	celdaXFin = x_end;
	celdaYFin = y_end;
	grid[x_end][y_end] = 0;			// Se asigna el valor 0 al objetivo.
	planPath(x_end, y_end, 1);		// Se planifica el camino.

}

/*
 * Método que encuentra el camino desde la posición inicial.
 */
void encontrarCamino(int x_ini, int y_ini){

	// Coordenadas de inicio.
	int x = x_ini;
	int y = y_ini;
	// Coordenadas del menor valor encontrado.
	int menorX = x_ini, menorY = y_ini;
	// Se introducen las dos primeras coordenadas.
	pathX[0] = x_ini;
	pathY[0] = y_ini;

	int ind = 1;			// Índice para ir guardando el camino.
	while(grid[x][y] != 0) {
		// Comprobamos si no hay obstáculo en medio y que es menor.
		if(grid[x-1][y] != -1 && grid[x-2][y] < grid[menorX][menorY]) {
			menorX = x-2;		// Asignamos el nuevo menor.
		}
		else if(grid[x+1][y] != -1 && grid[x+2][y] < grid[menorX][menorY]) {
			menorX = x+2;		// Asignamos el nuevo menor.
		}
		else if(grid[x][y-1] != -1 && grid[x][y-2] < grid[menorX][menorY]) {
			menorY = y-2;		// Asignamos el nuevo menor.
		}
		else if(grid[x][y+1] != -1 && grid[x][y+2] < grid[menorX][menorY]) {
			menorY = y+2;		// Asignamos el nuevo menor.
		}
		grid[x][y] = 99-ind;		// Indicamos el orden del camino.
		// Se actualizan los menores.
		x = menorX;
		y = menorY;
		// Se meten las coordenadas del camino.
		pathX[ind] = x;
		pathY[ind] = y;
		ind++;			// Se actualiza el índice.
	}
}

/*
* Método que replanifica la trayectoria al detectar un obstáculo.
*/
void rePlanPath(int celdaX, int celdaY){

	planPath(celdaX, celdaY, celdaXFin, celdaYFin);			// Se replanifica la ruta.
	encontrarCamino(celdaX, celdaY);		// Volver a encontrar el camino.

	OpenWrite(hFileHandleCuad, nIoCuadricula, cuadricula, nFileSizeCuad);

	string sString;
	for(int i = 2*sizeY; i >= 0; i--) {
		for(int j = 0; j <= 2*sizeX; j++) {
			stringFormat(sString, "%d ", grid[j][i]);
    	WriteText(hFileHandleCuad, nIoCuadricula, sString);
		}
    WriteText(hFileHandleCuad, nIoCuadricula, "\n");
	}

	for(int j = 0; j <= 20; j++) {
		stringFormat(sString, "%d ", pathX[j]);
    WriteText(hFileHandleCuad, nIoCuadricula, sString);
	}
   WriteText(hFileHandleCuad, nIoCuadricula, "\n");

   for(int i = 0; i <= 20; i++) {
    	stringFormat(sString, "%d ", pathY[i]);
    	WriteText(hFileHandleCuad, nIoCuadricula, sString);
	}



}

/*
* Método que redondea las coordenadas por si el robot se ha desviado.
*/
int redondearCoord(float coord) {

	float div = coord / sizeCell;
	float resto = div - (int)(div);
	int signo = 1, resultado = 0;
	if(div != 0){
		signo = div / div;
	}
	if(resto >= 0.75){
		resultado = (((int)(div))*2 + 1);

	} else{
		resultado = ((int)(div));
		resultado = resultado*signo*2;
	}

	return resultado;

}

/*
* Método que detecta si hay un obstáculo en la trayectoria.
*/
bool detectObstacle(float theta){

	int distancia = 31;		// Distancia al obstáculo.

	if(SensorValue[sonar] <= distancia){
		// Se ha detectado el obstáculo.
		float x,y, theta;			// Variables para la odometría.
		readOdometry(x,y,theta);		// Se lee la odometría.

		// Se obtiene la celda en la que está el obstáculo.
		int celdaX = redondearCoord(x) + pathX[0];
		int celdaY = redondearCoord(y) + pathY[0];
		// Se obtiene el vecino de la celda donde está el obstáculo.
		int orientacion = 0;
		int  xconn = celdaX, yconn = celdaY;
		if ((theta <= numPi/4 && theta >= 0.0) || (theta >= -numPi/4 && theta <= 0.0)) {
			xconn++;
		} else if (theta <= 3*numPi/4 && theta >= numPi/4) {
			yconn++;
		} else if(theta >= 3*numPi/4 || theta <= -3*numPi/4) {
			xconn--;
		} else if(theta >= -3*numPi/4 && theta <= -numPi/4) {
			yconn--;
		}

		//setConnection(celdaX, celdaY, orientacion);
		connectionsMatrix[xconn][yconn] = false;
		rePlanPath(celdaX, celdaY);		// Se replanifica la ruta.

		return true;
	}

	return false;
}

/*
* Método que planifica el camino desde la posición actual hasta una celda
* dada.
*/
bool go(int cellX, int cellY, bool mismaOri){

	float x, y, theta;			// Variables para la odometría.
	readOdometry(x,y,theta);			// Se lee la odometría.

	// Se saca la celda en la que estamos.
	int coordX = redondearCoord(x) + pathX[0];
	int coordY = redondearCoord(y) + pathY[0];

	nxtDisplayTextLine(5, "%d-%d", cellX, cellY);

	if(mismaOri){			// Si sigue la misma orientación, se asigna solo lineal.
		setSpeed(150,0);			// Se asigna la velocidad lineal.
		readOdometry(x,y,theta);			// Se lee la odometría.
		int recorridoX = abs(x);
		int recorridoY = abs(y);

		// Se comprueba si se ha llegado al objetivo.
		while(abs(x) <= recorridoX + sizeCell && abs(y) <= recorridoY + sizeCell
				&& abs(x) >= recorridoX - sizeCell && abs(y) >= recorridoY - sizeCell){
			nxtDisplayTextLine(6, "%d-%d", x, y);
			readOdometry(x,y,theta);
		}

		return detectObstacle(theta);			// Se detecta el obstáculo.

	}
	else{				// Si hay que girar...
		float w = 0.0;			// Velocidad angular.
		float actual = 0.0;

		if(coordX == cellX){				// Si el cambio de coordenadas es en Y..
			// Se calcula la direción de giro.
			float diff = coordY - cellY;
			float diffAngulo = abs(theta) - numPi/2;
			actual = theta;			// Se obtiene el ángulo actual de giro.
			// Se calcula la velocidad angular con su signo.
			w = diff/abs(diff) * numPi/2 * (diffAngulo)/abs(diffAngulo);
		}
		else{					// Si el camino de coordenadas es en X..
			// Se calcula la dirección de giro.
			float diff = coordX - cellX;
			// Se calcula la velocidad angular con su signo.
			actual = theta;			// Se obtiene el ángulo actual de giro.
			if(theta == 0){
				theta = 1;
			}
			w = diff/abs(diff) * numPi/2 * theta/abs(theta);
		}

		setSpeed(0,w);			// Se asigna la velocidad.
		readOdometry(x,y,theta);		// Se lee la odometría.

		while(abs(theta-actual) < numPi/2) {		// Mientras no se llegue al objetivo...
			readOdometry(x,y,theta);		// Se actualiza la odometría leída.
		}

		bool hayObstaculo = detectObstacle(theta);
		if(!hayObstaculo){			// Se detecta si hay un obstáculo.
			go(cellX, cellY, true);		// Se realiza el movimiento lineal.
		}
		return hayObstaculo;
	}

}

/*
* Método que recorre el camino hasta llegar al objetivo.
*/
void recorrerCamino() {

	char ori = 'Y';				// Variable para la orientación.
	bool mismaOri = false;		// Booleano que indica si sigue la misma orientación.
	bool replan = false;			// Variable que indica si tiene que replanificar.
	bool seguir = true;
	int ind = 1;			// Indice para recorrer el camino.
	while(seguir){			// Mientras no se llegue al objetivo.

		// Se comprueba la orientación y si sigue la misma.
		if(ori != 'X' && pathX[ind-1] == pathX[ind]){
			mismaOri = true;
			nxtDisplayTextLine(1, "Celda: %d-%d", pathX[ind], pathY[ind]);
			replan = go(pathX[ind],pathY[ind], mismaOri);		// Indica que comience a avanzar.
		}
		else if(ori != 'Y' && pathY[ind-1] == pathY[ind]){
			mismaOri = true;
			nxtDisplayTextLine(1, "Celda: %d-%d", pathX[ind], pathY[ind]);
			replan = go(pathX[ind],pathY[ind], mismaOri);		// Indica que comience a avanzar.
		}
		else{
			mismaOri = false;
			if(pathX[ind-1] == pathX[ind]){
				ori = 'Y';
			} else {
				ori = 'X';
			}
			nxtDisplayTextLine(1, "Celda: %d-%d", pathX[ind], pathY[ind]);
			replan = go(pathX[ind],pathY[ind], mismaOri);		// Indica que comience a avanzar.
		}

		if(replan){		// Si ha replanificado, se reinicia el índice.
			ind = 0;
		}
		ind++;			// Se actualiza el índice.

		if(grid[pathX[ind-1]][pathY[ind-1]] == 0){
			seguir = false;
		}

	}

}
